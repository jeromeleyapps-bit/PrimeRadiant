/**
 * VISUALIZER V5.5 - DYNAMIC SCALES
 */
class RadiantVisualizerV5 {

    constructor(canvasId) {
        this.ctx = document.getElementById(canvasId).getContext('2d');
        this.chart = null;
        this.themes = {
            scenarioA: { line: 'rgba(0, 242, 255, 0.05)', median: '#00f2ff', glow: 'rgba(0, 242, 255, 0.5)' },
            scenarioB: { line: 'rgba(255, 170, 0, 0.05)', median: '#ffaa00', glow: 'rgba(255, 170, 0, 0.5)' }
        };
    }

    renderComparison(resultsA, resultsB = null) {
        const datasets = [];

        // Determine Start Age from Data
        const startAge = resultsA.raw_simulations[0][0].age;

        // Dynamic Density: Show 10% of total simulations, capped at 400 lines for performance
        const densityA = Math.min(400, Math.max(50, Math.floor(resultsA.raw_simulations.length / 10)));
        datasets.push(...this._buildSpaghettiDatasets(resultsA, 'scenarioA', densityA));
        datasets.push(this._buildMedianDataset(resultsA, 'scenarioA'));

        if (resultsB) {
            const densityB = Math.min(400, Math.max(50, Math.floor(resultsB.raw_simulations.length / 10)));
            datasets.push(...this._buildSpaghettiDatasets(resultsB, 'scenarioB', densityB));
            datasets.push(this._buildMedianDataset(resultsB, 'scenarioB'));
        }

        if (this.chart) this.chart.destroy();

        this.chart = new Chart(this.ctx, {
            type: 'line',
            data: { datasets }, // Labels generated by scale
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 },
                plugins: { legend: { display: false }, tooltip: { enabled: false } },
                scales: {
                    x: {
                        type: 'linear',
                        min: startAge, // DYNAMIC START
                        max: 120,
                        grid: { color: 'rgba(255,255,255,0.02)' },
                        ticks: { color: '#666', stepSize: 10 }
                    },
                    y: {
                        min: 0, max: 120, // Adjusted for high resilience
                        grid: { color: 'rgba(255,255,255,0.02)' }
                    }
                }
            }
        });
    }

    _buildSpaghettiDatasets(results, key, count) {
        const theme = this.themes[key];
        const subset = [];
        const source = results.raw_simulations;
        // Limit render count
        const max = Math.min(count, source.length);

        for (let i = 0; i < max; i++) {
            // Pick random if we have tons, or just sequential
            const sim = source[Math.floor(Math.random() * source.length)];
            const data = sim.map(p => ({ x: p.age, y: p.v }));

            subset.push({
                type: 'line', data,
                borderColor: theme.line, borderWidth: 1, pointRadius: 0, fill: false, tension: 0.4
            });
        }
        return subset;
    }

    _buildMedianDataset(results, key) {
        const theme = this.themes[key];
        const data = results.aggregated_data.map(d => ({ x: d.age, y: d.avgQuality }));
        return {
            type: 'line', data,
            borderColor: theme.median, borderWidth: 3,
            shadowBlur: 10, shadowColor: theme.glow,
            pointRadius: 0, tension: 0.4
        };
    }
}
window.RadiantVisualizerV5 = RadiantVisualizerV5;

/**
 * GENERATEUR DE RAPPORT SELDON (Portable)
 */
function generateSeldonReport(results, inputs) {
    if (!results || !results.aggregated_data) return "Données insuffisantes.";

    const data = results.aggregated_data;
    // Trouver l'Age Critique (Probabilité survie < 50%)
    let criticalAge = "Non atteint (>120)";
    let p50 = data.find(d => d.survivalRate < 50);
    if (p50) criticalAge = p50.age + " ans";

    // Trouver le "Seldon Point" (Pic de mortalité / Chute brutale de qualité)
    // Ici on cherche la plus forte baisse d'énergie vitale
    let maxDrop = 0;
    let seldonPoint = 0;
    for (let i = 1; i < data.length; i++) {
        let drop = data[i - 1].avgQuality - data[i].avgQuality;
        if (drop > maxDrop) {
            maxDrop = drop;
            seldonPoint = data[i].age;
        }
    }

    const startAge = inputs.age || 30;
    const horizon = criticalAge === "Non atteint (>120)" ? 120 : parseInt(criticalAge);
    const yearsLeft = horizon - startAge;

    const report = `
=========================================
          RAPPORT SELDON (v7.2)          
=========================================
ID SUJET    : ${inputs.gender} / ${startAge} ans
SIMULATIONS : ${results.raw_simulations.length} Itérations
CHAOS MODE  : ${window.app && window.app.crisisMode ? "ACTIF (CRITIQUE)" : "INACTIF (STABLE)"}

--- ANALYSE TEMPORELLE ---
> Espérance Prédite : ${criticalAge}
> Horizon de Vie    : +${yearsLeft} années probables
> Point de Rupture  : ${seldonPoint} ans (Risque Max)

--- FACTEURS DETERMINANTS ---
[+] Forces (Protection) :
${_analyzeStrengths(inputs)}

[-] Faiblesses (Entropie) :
${_analyzeWeaknesses(inputs)}

--- CONCLUSION DU MOTEUR ---
La trajectoire montre une stabilité jusqu'à ${seldonPoint} ans.
Au-delà, la divergence stochastique augmente de 400%.
Conseil : Renforcer le "Temple Biologique" avant 
l'atteinte du point de rupture.

=========================================
    FIN DE TRANSMISSION - PRIME RADIANT    
=========================================
`;
    return report;
}

function _analyzeStrengths(i) {
    let s = [];
    if (i.optimism > 7) s.push("- Psyché : Haur Nv. Optimisme");
    if (i.stress_cortisol < 4) s.push("- Vecteur : Stress Maîtrisé");
    if (i.bmi > 20 && i.bmi < 25) s.push("- Temple : IMC Optimal");
    if (s.length === 0) return "- Aucune force majeure détectée.";
    return s.join("\n");
}

function _analyzeWeaknesses(i) {
    let w = [];
    if (i.stress_cortisol > 7) w.push("- Vecteur : Stress Chronique Critique");
    if (i.optimism < 4) w.push("- Psyché : Déficit Espérance");
    if (i.gender === 'M') w.push("- Génétique : Facteur de Risque Masculin");
    return w.join("\n");
}

window.generateSeldonReport = generateSeldonReport;
